-- üìå Chargement de Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

if not Rayfield then
    warn("‚ùå Rayfield UI n'a pas pu √™tre charg√© !")
    return
end
print("‚úÖ Rayfield UI charg√© avec succ√®s !")

-- üîπ Cl√© d'acc√®s au menu
local Window = Rayfield:CreateWindow({
    Name = "Rivals Aimbot",
    LoadingTitle = "Rivals Aimbot v1.0",
    LoadingSubtitle = "By azfasty",
    Theme = "AmberGlow",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RivalsConfig",
        FileName = "AimbotSettings"
    },
    KeySystem = true,
    KeySettings = {
        Title = "Rivals Key System",
        Subtitle = "Entrez votre cl√© pour acc√©der au menu",
        Note = "Contactez le d√©veloppeur pour obtenir une cl√©",
        FileName = "RivalsKey",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"RivalsAimbot123", "TestKey987"}  -- üîë Liste des cl√©s valides
    }
})

-- üîπ Variables Aimbot & ESP
local aimlock = false
local alwaysLock = false
local drawFOV = false
local aimSmoothness = 5
local aimFOV = 100

local espEnabled = false
local boxEnabled = false
local boneEnabled = false
local lineEnabled = false
local nameEnabled = false

local fovColor = Color3.fromRGB(255, 255, 255)
local espColor = Color3.fromRGB(255, 0, 0)

-- üìå Onglet AIMBOT
local AimbotTab = Window:CreateTab("Aimbot", "crosshair")

AimbotTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Flag = "Aimbot",
    Callback = function(state)
        aimlock = state
    end
})

AimbotTab:CreateToggle({
    Name = "Always Lock (Mobile)",
    CurrentValue = false,
    Flag = "AlwaysLock",
    Callback = function(state)
        alwaysLock = state
    end
})

AimbotTab:CreateToggle({
    Name = "Draw FOV",
    CurrentValue = false,
    Flag = "DrawFOV",
    Callback = function(state)
        drawFOV = state
    end
})

AimbotTab:CreateSlider({
    Name = "FOV Size",
    Range = {50, 300},
    Increment = 5,
    CurrentValue = aimFOV,
    Flag = "FOVSize",
    Callback = function(value)
        aimFOV = value
    end
})

AimbotTab:CreateSlider({
    Name = "Smoothness",
    Range = {1, 20},
    Increment = 1,
    CurrentValue = aimSmoothness,
    Flag = "Smoothness",
    Callback = function(value)
        aimSmoothness = value
    end
})

AimbotTab:CreateColorPicker({
    Name = "FOV Color",
    Color = fovColor,
    Flag = "FOVColor",
    Callback = function(color)
        fovColor = color
    end
})

-- üìå Onglet ESP
local EspTab = Window:CreateTab("ESP", "eye")

EspTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false,
    Flag = "EnableESP",
    Callback = function(state)
        espEnabled = state
    end
})

EspTab:CreateColorPicker({
    Name = "ESP Color",
    Color = espColor,
    Flag = "ESPColor",
    Callback = function(color)
        espColor = color
    end
})

-- üìå Onglet MISC
local MiscTab = Window:CreateTab("Misc", "tool")

MiscTab:CreateButton({
    Name = "Se t√©l√©porter au joueur le plus proche",
    Callback = function()
        local closestPlayer = nil
        local shortestDistance = math.huge
        local player = game.Players.LocalPlayer
        local character = player.Character

        if character and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character.HumanoidRootPart

            for _, p in pairs(game.Players:GetPlayers()) do
                if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (p.Character.HumanoidRootPart.Position - rootPart.Position).magnitude
                    if distance < shortestDistance then
                        closestPlayer = p
                        shortestDistance = distance
                    end
                end
            end

            if closestPlayer then
                character.HumanoidRootPart.CFrame = closestPlayer.Character.HumanoidRootPart.CFrame
            end
        end
    end
})

-- üéØ Aimbot avec WallChecker et DeadChecker
local function getClosestTarget()
    local closestTarget = nil
    local shortestDistance = aimFOV

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            -- ‚úÖ DeadChecker : Ignorer les joueurs morts
            if player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health <= 0 then
                continue
            end

            -- ‚úÖ WallChecker : V√©rifie si un mur bloque la vue
            local camera = workspace.CurrentCamera
            local ray = Ray.new(camera.CFrame.Position, (player.Character.Head.Position - camera.CFrame.Position).unit * 500)
            local hitPart, _ = workspace:FindPartOnRay(ray, game.Players.LocalPlayer.Character)

            if hitPart and hitPart:IsDescendantOf(player.Character) then
                local headPosition = camera:WorldToViewportPoint(player.Character.Head.Position)
                local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                local distance = (Vector2.new(headPosition.X, headPosition.Y) - screenCenter).Magnitude

                if distance < shortestDistance then
                    closestTarget = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestTarget
end

-- ‚úÖ V√©rification du bon chargement
print("üî• Aimbot & ESP charg√©s avec Rayfield UI !")
